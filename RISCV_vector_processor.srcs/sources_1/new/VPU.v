`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2025/06/16 08:45:35
// Design Name: 
// Module Name: VPU
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module VPU #(
    // Parameters
    // ICM
    parameter ICM_ADDR_WIDTH = 2              , // Address width for instruction cache
    parameter ICM_NUMBER = 2^ICM_ADDR_WIDTH   , // Number of instruction cache lines
    parameter INST_WIDTH = 32                 , // Instruction data width
    // Scalar 
    parameter REG_ADDR_WIDTH = 5              , // Address width for scalar registers
    parameter DCM_ADDR_WIDTH = 10             , // Address width for scalar DCM
    parameter REG_NUMBER = 2^REG_ADDR_WIDTH   , // Number of scalar registers
    parameter DCM_NUMBER = 2^DCM_ADDR_WIDTH   , // Number of scalar data cache lines
    parameter DATA_WIDTH = 32                 , // Data width for scalar registers
    //Vector 
    parameter VREG_ADDR_WIDTH = 5             , // Address width for vector registers
    parameter VDCM_ADDR_WIDTH = 10            , // Address width for vector DCM
    parameter VREG_NUMBER = 2^VREG_ADDR_WIDTH , // Number of vector registers
    parameter VDCM_NUMBER = 2^VDCM_ADDR_WIDTH , // Number of vector data cache lines
    parameter VREG_DATA_WIDTH = 32            , // Data width for vector registers
    parameter VECTOR_LENGTH = 8                // Number of elements in a vector register
)(
    input clk,
    input rst_n,
    // write to DCM
    input                                          write_mode    ,
    input  [ICM_ADDR_WIDTH                  - 1:0] icm_wr_addr   ,
    input  [DCM_ADDR_WIDTH                  - 1:0] scalar_wr_addr,
    input  [VDCM_ADDR_WIDTH                 - 1:0] vector_wr_addr,
    input  [INST_WIDTH                      - 1:0] inst_data,
    input  [DATA_WIDTH                      - 1:0] scalar_wr_data,
    input  [VREG_DATA_WIDTH * VECTOR_LENGTH - 1:0] vector_wr_data,
    // start the VPU
    input                                         start         ,
    // read out DCM results
    input                                          read_mode     ,
    input  [DCM_ADDR_WIDTH                  - 1:0] scalar_rd_addr,
    input  [VDCM_ADDR_WIDTH                 - 1:0] vector_rd_addr,
    output [DATA_WIDTH                      - 1:0] ScalarReadData,
    output [VREG_DATA_WIDTH * VECTOR_LENGTH - 1:0] VectorReadData
    );
    
    

    /***** Internal signals *****/
        //ICM inputs
        reg [ICM_ADDR_WIDTH-1:0] pc; // program counter
        // Dispatch inputs
        wire [31:0] instruction;
        // ImmGen inputs
        wire [31:0] InstImm;
        // ImmGen outputs
        wire [31:0] imm; // Immediate value generated by ImmGen
        // ScalarRF input Mux
        wire ScalarRegRdSel; // selects which data write to ScalarRF, 0: imm, 1: ScalarDCM output
        // ScalarRF inputs
        wire [4:0]  rs1_addr;
        wire [4:0]  rs2_addr;
        wire [4:0]  rd_addr;
        wire [DATA_WIDTH-1:0] rd_data;
        wire ScalarRegWriteEn; // Write enable signal for scalar register file
        // ScalarRF outputs
        wire [DATA_WIDTH-1:0] rs1_data; // Data read from scalar register rs1
        wire [DATA_WIDTH-1:0] rs2_data; // Data read from scalar register rs2
        // ScalarDCM inputs
        wire ScalarMemRead; // Read enable signal for scalar data cache memory
        wire ScalarMemWrite; // Write enable signal for scalar data cache memory
        wire [DCM_ADDR_WIDTH - 1:0] ScalarMemAddr; // Address for scalar data cache memory
        wire [DATA_WIDTH - 1:0] ScalarMemWriteData; // Write data for scalar data cache memory
        // ScalarDCM outputs
        // wire [DATA_WIDTH - 1:0] ScalarReadData; // Data read from scalar data cache memory
        
        // VectorRF input Mux
        wire VectorRegRdSel; // selects which data write to VectorRF, 0: MACResult, 1: VectorDCM output
        // VectorRF inputs
        wire [4:0]  vrs1_addr;
        wire [4:0]  vrs2_addr;
        wire [4:0]  vrd_addr;
        wire [VREG_DATA_WIDTH * VECTOR_LENGTH - 1:0] vrd_data; // Data to write to vector register
        wire VectorRegWriteEn; // Write enable signal for vector register file
        // VectorRF outputs
        wire [VREG_DATA_WIDTH * VECTOR_LENGTH - 1:0] vrs1_data; // Data read from vector register vrs1
        wire [VREG_DATA_WIDTH * VECTOR_LENGTH - 1:0] vrs2_data; // Data read from vector register vrs2
        // VectorDCM inputs
        wire VectorMemRead; // Read enable signal for vector data cache memory
        wire VectorMemWrite; // Write enable signal for vector data cache memory
        wire [VDCM_ADDR_WIDTH - 1:0] VectorMemAddr; // Address for vector data cache memory
        wire [VREG_DATA_WIDTH * VECTOR_LENGTH - 1:0] VectorMemWriteData; // Write data for vector data cache memory
        // VectorDCM outputs
        // wire [VREG_DATA_WIDTH * VECTOR_LENGTH - 1:0] VectorReadData; // Data read from vector data cache memory
        // MAC input muxs
        reg [DATA_WIDTH - 1:0] ScalarReadData_q;
        wire MACScalarSel; // selects which data to input into MAC as scalar
        wire MACIn1MuxSel; // selects which data to input into MAC as In1
        wire MACIn2MuxSel; // selects which data to input into MAC as In2
        wire [DATA_WIDTH - 1:0] MACscalar;
        wire [DATA_WIDTH * VECTOR_LENGTH - 1:0] MACvec_a; // [VREG_DATA_WIDTH*VECTOR_LENGTH-1 : 0]
        wire [DATA_WIDTH * VECTOR_LENGTH - 1:0] MACvec_b; // [VREG_DATA_WIDTH*VECTOR_LENGTH-1 : 0]
        // MAC outputs
        wire mode; // 0: mac, 1: reset
        wire [DATA_WIDTH * VECTOR_LENGTH - 1:0] MACResult; // Result of the MAC operation

    /***** Module instantiations *****/
    // PC
    always @(posedge clk or negedge rst_n) begin
        if(!rst_n) begin
            pc <= 0;
        end
        else if (start) begin
            pc <= pc + 1; // Increment PC on each clock cycle when start is high
        end
        else begin
            pc <= pc; // Hold PC value when start is low
        end
    end

    // ICM instance
    ICM #(
        .ADDR_WIDTH(ICM_ADDR_WIDTH),
        .INST_WIDTH(INST_WIDTH),
        .INIT_FILE("D:/Vivado Workplace/RISCV_vector_processor/RISCV_vector_processor.srcs/sim_1/new/instruction.vmem")
        ) icm_inst (
        // Inputs
        .clk(clk),
        .write(write_mode),
        .addr(write_mode ? icm_wr_addr : pc),
        .instruction_in(inst_data),
        // Outputs
        .instr(instruction)
    );

    // Dispatch instance
    Dispatch #(
        .INST_WIDTH(INST_WIDTH)
        ) dispatch_inst (
        // Inputs
        .clk(clk),
        .rst_n(rst_n),
        .instruction(instruction),
        // Outputs
        .InstImm(InstImm),
        .rs1(rs1_addr),
        .rs2(rs2_addr),
        .rd(rd_addr),
        .vrs1(vrs1_addr),
        .vrs2(vrs2_addr),
        .vrd(vrd_addr),
        .mode(mode)
    );

    // ImmGen instance
    ImmGen #(
        .WIDTH(DATA_WIDTH)
        ) immgen_inst (
        // Inputs
        .clk(clk),
        .rst_n(rst_n),
        .InstImm(InstImm),
        // Outputs
        .Imm(imm)
    );

    // Control instance
    Control #(
        .INST_WIDTH(INST_WIDTH)
        ) control_inst (
        // Inputs
        .clk(clk),
        .rst_n(rst_n),
        .instruction(instruction),
        // Outputs
        .ScalarRegWriteEn(ScalarRegWriteEn),  // Write enable signal for scalar register file
        .ScalarRegRdSel(ScalarRegRdSel),      // selects which data write to ScalarRF, 0: imm, 1: ScalarDCM output
        .ScalarMemRead(ScalarMemRead),        // Read enable signal for scalar data cache memory
        .ScalarMemWrite(ScalarMemWrite),      // Write enable signal for scalar data cache memory
        .VectorRegWriteEn(VectorRegWriteEn),  // Write enable signal for vector register file
        .VectorRegRdSel(VectorRegRdSel),      // selects which data write to VectorRF, 0: MACResult, 1: VectorDCM output
        .VectorMemRead(VectorMemRead),        // Read enable signal for vector data cache memory
        .VectorMemWrite(VectorMemWrite),      // Write enable signal for vector data cache memory
        .MACScalarSel(MACScalarSel),          // selects data from ScalarDCM(1) or ScalarRF(0) to MAC scalar input
        .MACIn1MuxSel(MACIn1MuxSel),          // selects data from VectorDCM(1) or VectorRF(0) to MAC input 1
        .MACIn2MuxSel(MACIn2MuxSel)           // selects data from VectorDCM(1) or VectorRF(0) to MAC input 2
    );

    // Mux for rd_data selection
        // If ScalarRegRdSel is 0, use immediate value; if 1, use data from ScalarRF
        assign rd_data = (ScalarRegRdSel) ? ScalarReadData : InstImm; 
    
    // ScalarRF instance
    ScalarRF #(
        .REG_ADDR_WIDTH(REG_ADDR_WIDTH),
        .REG_NUMBER(REG_NUMBER),
        .REG_DATA_WIDTH(DATA_WIDTH)
        ) scalar_rf_inst (
        // Inputs
        .clk(clk),
        .rst_n(rst_n),
        .rs1_addr(rs1_addr),
        .rs2_addr(rs2_addr),
        .rd_addr(rd_addr),
        .rd_data(rd_data), // Use immediate value as write data
        .ScalarRegWriteEn(ScalarRegWriteEn), // Write enable signal
        // Outputs
        .rs1_data(rs1_data),
        .rs2_data(rs2_data)
    );

    // ScalarDCM instance
    assign ScalarMemAddr = (write_mode == 1) ? scalar_wr_addr :
                           (read_mode  == 1) ? scalar_rd_addr :
                           (imm[DCM_ADDR_WIDTH - 1:0] + rs1_data[DCM_ADDR_WIDTH - 1:0]);
    assign ScalarMemWriteData = rs2_data; // Write data for scalar data cache memory
    ScalarDCM #(
        .ADDR_WIDTH(DCM_ADDR_WIDTH),
        .DATA_WIDTH(DATA_WIDTH),
        .INIT_FILE("D:/Vivado Workplace/RISCV_vector_processor/RISCV_vector_processor.srcs/sim_1/new/ScalarDCM.vmem")
        ) scalar_dcm_inst (
        // Inputs
        .clk(clk),
        .ScalarMemRead(ScalarMemRead || read_mode), // Read enable signal
        .ScalarMemWrite(ScalarMemWrite || write_mode), // Write enable signal
        .addr(ScalarMemAddr), // Address for scalar data cache memory
        .write_data(write_mode ? scalar_wr_data : ScalarMemWriteData), // Write data for scalar data cache memory
        // Outputs
        .read_data(ScalarReadData) // Data read from scalar data cache memory
    );

    // Mux for vrd_data selection
        // select between MACResult and VectorReadData
        assign vrd_data = (VectorRegRdSel) ? VectorReadData : MACResult; // 0: MACResult, 1: VectorDCM output

    // VectorRF instance
    VectorRF #(
        .VREG_ADDR_WIDTH(VREG_ADDR_WIDTH),
        .VREG_NUMBER(VREG_NUMBER),
        .VREG_DATA_WIDTH(VREG_DATA_WIDTH),
        .VECTOR_LENGTH(VECTOR_LENGTH)
        ) vector_rf_inst (
        // Inputs
        .clk(clk),
        .rst_n(rst_n),
        .vrs1_addr(vrs1_addr),
        .vrs2_addr(vrs2_addr),
        .vrd_addr(vrd_addr),
        .vrd_data(vrd_data), // Data to write to vector register
        .VectorRegWriteEn(VectorRegWriteEn), // Write enable signal
        // Outputs
        .vrs1_data(vrs1_data),
        .vrs2_data(vrs2_data)
    );

    // VectorDCM instance
    assign VectorMemAddr = (write_mode == 1) ? vector_wr_addr :
                           (read_mode  == 1) ? vector_rd_addr : 
                           (imm[VDCM_ADDR_WIDTH - 1:0] + rs1_data[VDCM_ADDR_WIDTH - 1:0]);
    assign VectorMemWriteData = vrs2_data; // Write data for vector data cache memory
    VectorDCM #(
        .ADDR_WIDTH(VDCM_ADDR_WIDTH),
        .DATA_WIDTH(VREG_DATA_WIDTH),
        .VECTOR_LENGTH(VECTOR_LENGTH),
        .INIT_FILE("D:/Vivado Workplace/RISCV_vector_processor/RISCV_vector_processor.srcs/sim_1/new/VectorDCM.vmem")
        ) vector_dcm_inst (
        // Inputs
        .clk(clk),
        .VectorMemRead(VectorMemRead || read_mode), // Read enable signal
        .VectorMemWrite(VectorMemWrite || write_mode), // Write enable signal
        .addr(VectorMemAddr), // Address for vector data cache memory
        .write_data(write_mode ? vector_wr_data : VectorMemWriteData), // Write data for vector data cache memory
        // Outputs
        .read_data(VectorReadData) // Data read from vector data cache memory
    );

    // MAC instance
    always @(posedge clk or negedge rst_n) begin
        if(!rst_n) begin
            ScalarReadData_q <= 0;
        end
        else begin
            ScalarReadData_q <= ScalarReadData;
        end
    end
    assign MACscalar = MACScalarSel ? ScalarReadData_q : rs1_data; // Scalar input for MAC
    assign MACvec_a  = MACIn1MuxSel ? VectorReadData : vrs1_data;
    assign MACvec_b  = MACIn2MuxSel ? VectorReadData : vrs2_data;
    MAC #(
        .DATA_WIDTH(VREG_DATA_WIDTH),
        .VECTOR_LENGTH(VECTOR_LENGTH)
        ) mac_inst (
        // Inputs
        .clk(clk),
        .rst_n(rst_n),
        .mode(mode),
        .scalar(MACscalar),
        .vec_a(MACvec_a),
        .vec_b(MACvec_b),
        // Outputs
        .out(MACResult) // Data to write back to vector register file
    );

endmodule
